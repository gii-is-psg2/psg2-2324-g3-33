/// <reference types="react" />

declare class BinaryLogicalPredicate implements NAryFunction<boolean> {
	left: NAryFunction<boolean>;
	right: NAryFunction<boolean>;
	op: BinaryLogicalOperator;
	constructor(left: NAryFunction<boolean>, right: NAryFunction<boolean>, operator: BinaryLogicalOperator);
	eval(): Promise<ResultValue<boolean>>;
	equals(other: NAryFunction<any>): boolean;
}
declare enum BinaryLogicalOperator {
	AND = 0,
	OR = 1,
	IFF = 2,
	IMPLIES = 3
}
export declare function Default({ children }: {
	children: React.ReactNode;
}): import("react/jsx-runtime").JSX.Element;
export declare function ErrorFallback({ children }: {
	children: React.ReactNode;
}): import("react/jsx-runtime").JSX.Element;
export declare function Feature({ children, expression }: {
	children: React.ReactNode;
	expression: NAryFunction<boolean>;
}): import("react/jsx-runtime").JSX.Element;
export declare function Loading({ children }: {
	children: React.ReactNode;
}): import("react/jsx-runtime").JSX.Element;
export declare function On({ children, expression }: {
	children: React.ReactNode;
	expression?: NAryFunction<boolean> | undefined;
}): import("react/jsx-runtime").JSX.Element;
export declare function PricingConfigurationRoutes({ pricingContext, returnTo, theme, onSave, }: PricingConfigurationRoutesProps): import("react/jsx-runtime").JSX.Element;
export declare function and(left: LogicBoolean, right: LogicBoolean): BinaryLogicalPredicate;
export declare function feature(featureId: string): NAryFunction<boolean>;
export declare function fetchWithPricingInterceptor(url: string, options: RequestInit): Promise<Response>;
export declare function iff(left: LogicBoolean, right: LogicBoolean): BinaryLogicalPredicate;
export declare function implies(left: LogicBoolean, right: LogicBoolean): BinaryLogicalPredicate;
export declare function or(left: LogicBoolean, right: LogicBoolean): BinaryLogicalPredicate;
export declare function searchNewTokenAndUpdate(res: Response): void;
export declare function useGenericFeature(options: GenericFeatureHookOptions): FeatureResponse;
export interface GenericFeatureHookOptions {
	key?: string;
	on: {
		expression: NAryFunction<boolean>;
		on: React.ReactNode;
	}[];
	default?: React.ReactNode;
	loading?: React.ReactNode;
	error?: React.ReactNode;
}
export interface NAryFunction<T> {
	eval: () => Promise<ResultValue<T>>;
	equals: (other: NAryFunction<any>) => boolean;
}
export interface PricingConfigurationRoutesProps {
	pricingContext: RawPricingContext;
	returnTo: string;
	theme?: string;
	onSave: (pricingContext: RawPricingContext) => void;
}
export interface RawAttributes {
	description: string;
	expression: string;
	serverExpression?: string;
	type: AttributeType;
	defaultValue: string | number | boolean;
}
export interface RawFeatureAttributes {
	[key: string]: RawAttributes;
}
export interface RawFeatures {
	[key: string]: {
		value: string | number | boolean;
	};
}
export interface RawPlan {
	description: string;
	price: number;
	currency: string;
	features: RawFeatures;
}
export interface RawPlans {
	[key: string]: RawPlan;
}
export interface RawPricingContext {
	features: RawFeatureAttributes;
	plans: RawPlans;
}
export type AttributeType = "NUMERIC" | "CONDITION" | "TEXT";
export type FeatureResponse = JSX.Element;
export type LogicBoolean = NAryFunction<boolean> | boolean;
export type ResultValue<T> = {
	value: T;
	isError: false;
	errorMessage?: undefined;
} | {
	value?: undefined;
	isError: true;
	errorMessage: string;
};

export {};
